const A=(e,t,n)=>Math.max(Math.min(e,n),t),w=(e,t,n)=>(A(e,t,n)-t)/(n-t),M="Right",d="Left",z=Math.PI,g=Math.PI*2;class s{constructor(t,n,i){var r,o,h,a,l,u;if(Array.isArray(t)){this.x=(r=t[0])!==null&&r!==void 0?r:0,this.y=(o=t[1])!==null&&o!==void 0?o:0,this.z=(h=t[2])!==null&&h!==void 0?h:0;return}if(t&&typeof t=="object"){this.x=(a=t.x)!==null&&a!==void 0?a:0,this.y=(l=t.y)!==null&&l!==void 0?l:0,this.z=(u=t.z)!==null&&u!==void 0?u:0;return}this.x=t??0,this.y=n??0,this.z=i??0}negative(){return new s(-this.x,-this.y,-this.z)}add(t){return t instanceof s?new s(this.x+t.x,this.y+t.y,this.z+t.z):new s(this.x+t,this.y+t,this.z+t)}subtract(t){return t instanceof s?new s(this.x-t.x,this.y-t.y,this.z-t.z):new s(this.x-t,this.y-t,this.z-t)}multiply(t){return t instanceof s?new s(this.x*t.x,this.y*t.y,this.z*t.z):new s(this.x*t,this.y*t,this.z*t)}divide(t){return t instanceof s?new s(this.x/t.x,this.y/t.y,this.z/t.z):new s(this.x/t,this.y/t,this.z/t)}equals(t){return this.x==t.x&&this.y==t.y&&this.z==t.z}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}cross(t){return new s(this.y*t.z-this.z*t.y,this.z*t.x-this.x*t.z,this.x*t.y-this.y*t.x)}length(){return Math.sqrt(this.dot(this))}distance(t,n=3){return Math.sqrt(n===2?Math.pow(this.x-t.x,2)+Math.pow(this.y-t.y,2):Math.pow(this.x-t.x,2)+Math.pow(this.y-t.y,2)+Math.pow(this.z-t.z,2))}lerp(t,n){return t.subtract(this).multiply(n).add(this)}unit(){return this.divide(this.length())}min(){return Math.min(Math.min(this.x,this.y),this.z)}max(){return Math.max(Math.max(this.x,this.y),this.z)}toSphericalCoords(t={x:"x",y:"y",z:"z"}){return{theta:Math.atan2(this[t.y],this[t.x]),phi:Math.acos(this[t.z]/this.length())}}angleTo(t){return Math.acos(this.dot(t)/(this.length()*t.length()))}toArray(t){return[this.x,this.y,this.z].slice(0,t||3)}clone(){return new s(this.x,this.y,this.z)}init(t,n,i){return this.x=t,this.y=n,this.z=i,this}static negative(t,n=new s){return n.x=-t.x,n.y=-t.y,n.z=-t.z,n}static add(t,n,i=new s){return n instanceof s?(i.x=t.x+n.x,i.y=t.y+n.y,i.z=t.z+n.z):(i.x=t.x+n,i.y=t.y+n,i.z=t.z+n),i}static subtract(t,n,i=new s){return n instanceof s?(i.x=t.x-n.x,i.y=t.y-n.y,i.z=t.z-n.z):(i.x=t.x-n,i.y=t.y-n,i.z=t.z-n),i}static multiply(t,n,i=new s){return n instanceof s?(i.x=t.x*n.x,i.y=t.y*n.y,i.z=t.z*n.z):(i.x=t.x*n,i.y=t.y*n,i.z=t.z*n),i}static divide(t,n,i=new s){return n instanceof s?(i.x=t.x/n.x,i.y=t.y/n.y,i.z=t.z/n.z):(i.x=t.x/n,i.y=t.y/n,i.z=t.z/n),i}static cross(t,n,i=new s){return i.x=t.y*n.z-t.z*n.y,i.y=t.z*n.x-t.x*n.z,i.z=t.x*n.y-t.y*n.x,i}static unit(t,n){const i=t.length();return n.x=t.x/i,n.y=t.y/i,n.z=t.z/i,n}static fromAngles(t,n){return new s(Math.cos(t)*Math.cos(n),Math.sin(n),Math.sin(t)*Math.cos(n))}static randomDirection(){return s.fromAngles(Math.random()*g,Math.asin(Math.random()*2-1))}static min(t,n){return new s(Math.min(t.x,n.x),Math.min(t.y,n.y),Math.min(t.z,n.z))}static max(t,n){return new s(Math.max(t.x,n.x),Math.max(t.y,n.y),Math.max(t.z,n.z))}static lerp(t,n,i){return n instanceof s?n.subtract(t).multiply(i).add(t):(n-t)*i+t}static fromArray(t){return Array.isArray(t)?new s(t[0],t[1],t[2]):new s(t.x,t.y,t.z)}static angleBetween(t,n){return t.angleTo(n)}static distance(t,n,i){return Math.sqrt(i===2?Math.pow(t.x-n.x,2)+Math.pow(t.y-n.y,2):Math.pow(t.x-n.x,2)+Math.pow(t.y-n.y,2)+Math.pow(t.z-n.z,2))}static toDegrees(t){return t*(180/z)}static normalizeAngle(t){let n=t%g;return n=n>z?n-g:n<-z?g+n:n,n/z}static normalizeRadians(t){return t>=z/2&&(t-=g),t<=-z/2&&(t+=g,t=z-t),t/z}static find2DAngle(t,n,i,r){const o=r-n,h=i-t;return Math.atan2(o,h)}static findRotation(t,n,i=!0){return i?new s(s.normalizeRadians(s.find2DAngle(t.z,t.x,n.z,n.x)),s.normalizeRadians(s.find2DAngle(t.z,t.y,n.z,n.y)),s.normalizeRadians(s.find2DAngle(t.x,t.y,n.x,n.y))):new s(s.find2DAngle(t.z,t.x,n.z,n.x),s.find2DAngle(t.z,t.y,n.z,n.y),s.find2DAngle(t.x,t.y,n.x,n.y))}static rollPitchYaw(t,n,i){if(!i)return new s(s.normalizeAngle(s.find2DAngle(t.z,t.y,n.z,n.y)),s.normalizeAngle(s.find2DAngle(t.z,t.x,n.z,n.x)),s.normalizeAngle(s.find2DAngle(t.x,t.y,n.x,n.y)));const r=n.subtract(t),o=i.subtract(t),a=r.cross(o).unit(),l=r.unit(),u=a.cross(l),x=Math.asin(a.x)||0,y=Math.atan2(-a.y,a.z)||0,c=Math.atan2(-u.x,l.x)||0;return new s(s.normalizeAngle(y),s.normalizeAngle(x),s.normalizeAngle(c))}static angleBetween3DCoords(t,n,i){t instanceof s||(t=new s(t),n=new s(n),i=new s(i));const r=t.subtract(n),o=i.subtract(n),h=r.unit(),a=o.unit(),l=h.dot(a),u=Math.acos(l);return s.normalizeRadians(u)}static getRelativeSphericalCoords(t,n,i,r){t instanceof s||(t=new s(t),n=new s(n),i=new s(i));const o=n.subtract(t),h=i.subtract(n),a=o.unit(),l=h.unit(),{theta:u,phi:x}=a.toSphericalCoords(r),{theta:y,phi:c}=l.toSphericalCoords(r),p=u-y,f=x-c;return{theta:s.normalizeAngle(p),phi:s.normalizeAngle(f)}}static getSphericalCoords(t,n,i={x:"x",y:"y",z:"z"}){t instanceof s||(t=new s(t),n=new s(n));const o=n.subtract(t).unit(),{theta:h,phi:a}=o.toSphericalCoords(i);return{theta:s.normalizeAngle(-h),phi:s.normalizeAngle(z/2-a)}}}const Y=e=>{const t=new s(e[21]),n=new s(e[251]),i=new s(e[397]),r=new s(e[172]),o=i.lerp(r,.5);return{vector:[t,n,o],points:[t,n,i,r]}},F=e=>{const t=Y(e).vector,n=s.rollPitchYaw(t[0],t[1],t[2]),i=t[0].lerp(t[1],.5),r=t[0].distance(t[1]),o=i.distance(t[2]);return n.x*=-1,n.z*=-1,{y:n.y*z,x:n.x*z,z:n.z*z,width:r,height:o,position:i.lerp(t[2],.5),normalized:{y:n.y,x:n.x,z:n.z},degrees:{y:n.y*180,x:n.x*180,z:n.z*180}}},D={eye:{[d]:[130,133,160,159,158,144,145,153],[M]:[263,362,387,386,385,373,374,380]},brow:{[d]:[35,244,63,105,66,229,230,231],[M]:[265,464,293,334,296,449,450,451]},pupil:{[d]:[468,469,470,471,472],[M]:[473,474,475,476,477]}},C=(e,t=d,{high:n=.85,low:i=.55}={})=>{const r=D.eye[t],o=q(e[r[0]],e[r[1]],e[r[2]],e[r[3]],e[r[4]],e[r[5]],e[r[6]],e[r[7]]),a=A(o/.285,0,2);return{norm:w(a,i,n),raw:a}},q=(e,t,n,i,r,o,h,a)=>{e=new s(e),t=new s(t),n=new s(n),i=new s(i),r=new s(r),o=new s(o),h=new s(h),a=new s(a);const l=e.distance(t,2),u=n.distance(o,2),x=i.distance(h,2),y=r.distance(a,2);return(u+x+y)/3/l},B=(e,t=d)=>{const n=new s(e[D.eye[t][0]]),i=new s(e[D.eye[t][1]]),r=n.distance(i,2),o=n.lerp(i,.5),h=new s(e[D.pupil[t][0]]),a=o.x-h.x,l=o.y-r*.075-h.y;let u=a/(r/2),x=l/(r/4);return u*=4,x*=4,{x:u,y:x}},I=(e,t,{enableWink:n=!0,maxRot:i=.5}={})=>{e.r=A(e.r,0,1),e.l=A(e.l,0,1);const r=Math.abs(e.l-e.r),o=n?.8:1.2,h=e.l<.3&&e.r<.3,a=e.l>.6&&e.r>.6;return t>i?{l:e.r,r:e.r}:t<-i?{l:e.l,r:e.l}:{l:r>=o&&!h&&!a?e.l:e.r>e.l?s.lerp(e.r,e.l,.95):s.lerp(e.r,e.l,.05),r:r>=o&&!h&&!a?e.r:e.r>e.l?s.lerp(e.r,e.l,.95):s.lerp(e.r,e.l,.05)}},X=(e,{high:t=.85,low:n=.55}={})=>{if(e.length!==478)return{l:1,r:1};const i=C(e,d,{high:t,low:n}),r=C(e,M,{high:t,low:n});return{l:i.norm||0,r:r.norm||0}},j=e=>{if(e.length!==478)return{x:0,y:0};{const t=B(e,d),n=B(e,M);return{x:(t.x+n.x)*.5||0,y:(t.y+n.y)*.5||0}}},E=(e,t=d)=>{const n=D.brow[t],i=q(e[n[0]],e[n[1]],e[n[2]],e[n[3]],e[n[4]],e[n[5]],e[n[6]],e[n[7]]),r=1.15,o=.125,h=.07,a=i/r-1;return(A(a,h,o)-h)/(o-h)},k=e=>{if(e.length!==478)return 0;{const t=E(e,d),n=E(e,M);return(t+n)/2||0}},G=e=>{const t=new s(e[133]),n=new s(e[362]),i=new s(e[130]),r=new s(e[263]),o=t.distance(n),h=i.distance(r),a=new s(e[13]),l=new s(e[14]),u=new s(e[61]),x=new s(e[291]),y=a.distance(l),c=u.distance(x);let p=y/o,f=c/h;p=w(p,.15,.7),f=w(f,.45,.9),f=(f-.3)*2;const O=f,m=w(y/o,.17,.5),R=A(w(O,0,1)*2*w(m,.2,.7),0,1),T=m*.4+m*(1-R)*.6,P=m*w(1-R,0,.3)*.1,H=w(P,.2,1)*(1-R)*.3,W=(1-R)*w(m,.3,1)*.4;return{x:f||0,y:p||0,shape:{A:T||0,E:H||0,I:R||0,O:W||0,U:P||0}}};class N{static solve(t,{runtime:n="tfjs",video:i=null,imageSize:r=null,smoothBlink:o=!1,blinkSettings:h=[]}={}){if(!t){console.error("Need Face Landmarks");return}if(i){const c=typeof i=="string"?document.querySelector(i):i;r={width:c.videoWidth,height:c.videoHeight}}if(n==="mediapipe"&&r)for(const c of t)c.x*=r.width,c.y*=r.height,c.z*=r.width;const a=F(t),l=G(t);h=h.length>0?h:n==="tfjs"?[.55,.85]:[.35,.5];let u=X(t,{high:h[1],low:h[0]});o&&(u=I(u,a.y));const x=j(t),y=k(t);return{head:a,eye:u,brow:y,pupil:x,mouth:l}}}N.stabilizeBlink=I;export{N as F};
//# sourceMappingURL=kalidokit-_jXEaiY1.js.map
